            
            
                                                           
                             
                                   1 
                                     
              
                
                
                                           CONTENT 
                 1    Cryptography Overview                                        4 
                     1.1  Elliptic Curve Cryptography                              4 
                         1.1.1 Introduction                                        4 
                         1.1.2 Digital Signature Algorithm                         5 
                     1.2  Threshold Key Sharing                                    6 
                         1.2.1 Shamir‚Äôs Secret Sharing Scheme                      6 
                         1.2.2 Linear Key Sharing Scheme                           7 
                         1.2.3 Shamir‚Äôs Scheme and Polynomial Interpolation        8 
                     1.3  Secure Multi-Party Computation                           9 
                         1.3.1 Background                                          9 
                         1.3.2 Classification                                     10 
                     1.4  Ring Signatures                                         12 
                 2    Locked Account System                                       12 
                     2.1  Secure Multi-Party Computation Operation                12 
                         2.1.1 Addition                                           13 
                         2.1.2 Multiplication                                     14 
                         2.1.3 Unary Inverse                                      16 
                     2.2  Locked Account Generation Scheme                        17 
                     2.3  Locked Account Signature Scheme                         18 
                                                   2 
                                                    
                   
                
                     2.4  Locked Account Key Share Updating                      19 
                 3    Smart Contract Token Transaction Anonymity                 20 
                     3.1  Ring Signature                                         20 
                     3.2  One-Time Account System                                22 
                         3.2.1 Composition                                       22 
                         3.2.2 Account Generation Algorithm                      23 
                     3.3  Stamp System                                           25 
                     3.4  Native Coin Transaction Privacy Protection             27 
                         3.4.1 Wancoin Smart Contract                            28 
                         3.4.2 Transaction Scenario                              28 
                         3.4.3 Transaction Flow                                  29 
                         3.4.4 Privacy Effect Analysis                           30 
                     3.5  Smart Contract Token Privacy Protection Scheme         31 
                         3.5.1 Transaction Scenario                              31 
                         3.5.2 Transaction Flow                                  31 
                         3.5.3 Privacy Effect Analysis                           34 
                      
                    
                
                
                                                  3 
                                                   
                   
                        
                       1  Cryptography Overview 
                       1.1  Elliptic Curve Cryptography 
                       1.1.1  Introduction  
                       Elliptic  curve  cryptography (ECC) is a public-key cryptography method that 
                       uses elliptic curves algebraic structures over finite fields. ECC provides security 
                                                                                               . 
                       using smaller keys than other cryptographic methods. ECC can be used for key 
                       agreement,  digital  signatures,  pseudo-random  generators,  etc.  ECC  can  be 
                       used for indirect encryption by using a symmetric encryption scheme with the 
                       key agreement.  
                       Let Ì∞∏Ì†µ be an elliptic curve defined over Ì∞∫Ì†µ, which is a finite field. Actually, it is a 
                       set of points described by the Weierstrass equation: 
                                      Ì∞∏Ì†µ/Ì∞∫Ì†µ =     Ì±•Ì†µ, Ì±¶Ì†µ 	 	Ì±¶Ì†µ) + Ì±éÌ†µ Ì±•Ì†µÌ±¶Ì†µ + Ì±éÌ†µ Ì±¶Ì†µ = Ì±•Ì†µ- + Ì±éÌ†µ Ì±•Ì†µ  +Ì±éÌ†µ Ì±•Ì†µ + Ì±éÌ†µ ,	 
                                                                   ,         -              ) )       .       /
                                      Ì±éÌ†µ , Ì±éÌ†µ , Ì±éÌ†µ , Ì±éÌ†µ , Ì±éÌ†µ , Ì±•Ì†µ, Ì±¶Ì†µ ‚àà Ì∞∫Ì†µ} ‚à™ {Ì±ÇÌ†µ}, Ì±ÇÌ†µ is the point at infinity 
                                       ,    -   )   .   /
                                                                             
                       The addition operation is defined on the elliptic curve. Ì±ÉÌ†µ and Ì±ÑÌ†µ represent two 
                       points on the elliptic curve Ì∞∏Ì†µ. Ì±ÉÌ†µ + Ì±ÑÌ†µ = Ì±ÖÌ†µ means that Ì±ÖÌ†µ is the symmetric point of 
                       the intersection of Ì∞∏Ì†µ and the line across Ì±ÉÌ†µ and Ì±ÑÌ†µ with respect to the x-axis. If 
                       Ì±ÉÌ†µ = Ì±ÑÌ†µ, Ì±ÖÌ†µ is the symmetric point of the intersection of Ì∞∏Ì†µ and the tangent line 
                       across  Ì±ÉÌ†µ .  Therefore  (Ì∞∏Ì†µ,+)  is  an  Abelian  group  defined  over  Ì∞∫Ì†µ  with  the 
                       identity	Ì±ÇÌ†µ.  
                       GivenÌ±ÉÌ†µ = (Ì±•Ì†µ ,Ì±¶Ì†µ ) ‚àà Ì∞∏Ì†µ,Ì±ÑÌ†µ = (Ì±•Ì†µ ,Ì±¶Ì†µ ) ‚àà Ì∞∏Ì†µ ,  if  Ì±•Ì†µ = Ì±•Ì†µ  and  Ì±¶Ì†µ = Ì±¶Ì†µ ,  then  Ì±ÉÌ†µ + Ì±ÑÌ†µ = Ì±ÇÌ†µ . 
                                       ,   ,                )  )               ,     )          ,     )
                                                                             4 
                                                                               
                             
                                                                                              )
                              Otherwise Ì±ÉÌ†µ +Ì±ÑÌ†µ = (Ì±•Ì†µ ,Ì±¶Ì†µ ) with Ì±•Ì†µ = ÌºÜÌ†µ ‚àí Ì±•Ì†µ ‚àí Ì±•Ì†µ ,Ì±¶Ì†µ = ÌºÜÌ†µ Ì±•Ì†µ ‚àí Ì±•Ì†µ                                         ‚àíÌ±¶Ì†µ : 
                                                                  -    -              -               ,       )    -           ,       -        ,
                                                                                           Ì±¶Ì†µ   ‚àíÌ±¶Ì†µ
                                                                                             )       , , Ì±ÉÌ†µ ‚â† Ì±ÑÌ†µ		
                                                                                           Ì±•Ì†µ   ‚àíÌ±•Ì†µ
                                                                                  ÌºÜÌ†µ =       ) ) ,                   
                                                                                           3Ì±•Ì†µ     +Ì±éÌ†µ
                                                                                               ,         , Ì±ÉÌ†µ = Ì±ÑÌ†µ
                                                                                               2Ì±¶Ì†µ
                                                                                                   ,
                               
                              1.1.2  Digital Signature Algorithm  
                              The  Elliptic  Curve  Digital  Signature  Algorithm  (ECDSA)  is  a  variant  of  the 
                              Digital Signature Algorithm (DSA) using elliptic curve cryptography. 
                              There is no inverse in ECDSA when calculating order, so it is easier to use than 
                              the Schnorr Digital Signature Algorithm, which is based on the intractability of 
                              discrete logarithms. ECDSA is also more efficient than the Schnorr signature 
                              because it is easier to calculate Ì∞ªÌ†µ(Ì±ÄÌ†µ) than Ì∞ªÌ†µ(Ì±ÄÌ†µ,Ì±ÖÌ†µ),    and  is  therefore  better 
                              used  for  safety  strength,  key  length,  efficiency,  computational  cost  and 
                              bandwidth attack resistance.  
                              Let us assume that Ì∞∏Ì†µ (Ì±éÌ†µ,Ì±èÌ†µ) is an elliptic curve whose order is N with basepoint 
                                                                   A
                              Ì±ÉÌ†µ. Ì±ÑÌ†µ is an arbitrary point on Ì∞∏Ì†µ (Ì±éÌ†µ,Ì±èÌ†µ) satisfying Ì±ÑÌ†µ = Ì±òÌ†µÌ±ÉÌ†µ. Then (Ì±òÌ†µ, Ì±ÑÌ†µ) becomes the 
                                                                                  A
                              key pair with Ì±òÌ†µ as the private key and Ì±ÑÌ†µ as the public key.  
                              ECDSA between sender A and receiver B is shown below:‚Ä® 
                              Step 1: Calculate the hash of a plain text message Ì±ÄÌ†µ using a hash function such as 
                              MD5 or SHA-1: Ì±°Ì†µ = Ì∞ªÌ†µ(Ì±ÄÌ†µ).  
                              Step 2: Take a random integer Ì±òÌ†µ as the private key in	[1,Ì±ÅÌ†µ ‚àí 1]. 
                              Step 3: Calculate the public key Ì±ÑÌ†µ = Ì±òÌ†µÌ±ÉÌ†µ. 
                              Step 4: Calculate Ì±üÌ†µ = Ì±ÑÌ†µ 	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ÅÌ†µ. Ì±ÑÌ†µ  is the abscissa of Ì±ÑÌ†µ. If Ì±üÌ†µ = 0, return to Step 2.  
                                                                    K                K
                                                                                                     5 
                                                                                                       
                                     
                                              Q,
                    Step 5: Calculate Ì±†Ì†µ = Ì±òÌ†µ   (Ì±°Ì†µ + Ì±üÌ†µÌ±òÌ†µ)	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ÅÌ†µ. Ì±òÌ†µ is the private key of A. If	Ì±†Ì†µ = 0, return to 
                    Step 2.  
                    Step 6: A delivers (Ì±üÌ†µ,Ì±†Ì†µ) to B as a signature.  
                     
                    The verification of (Ì≤ìÌ†µ,Ì≤îÌ†µ) by B is shown below:  
                    Step  1:  Verify  whether Ì±üÌ†µ and Ì±†Ì†µ are  positive  integers  in [1,Ì±ÅÌ†µ ‚àí 1].  If  not,  the 
                    signature is invalid.  
                    Step 2: Calculate the hash of plain text Ì±ÄÌ†µ: Ì±°Ì†µ = Ì∞ªÌ†µ(Ì±ÄÌ†µ).  
                    Step 3: Calculate Ì±íÌ†µ = Ì±†Ì†µQ,	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ÅÌ†µ. 
                    Step 4: Calculate Ì±¢Ì†µ = Ì±°Ì†µÌ±íÌ†µ	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ÅÌ†µ. 
                    Step 5: Calculate Ì±£Ì†µ = Ì±üÌ†µÌ±íÌ†µ	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ÅÌ†µ. 
                    Step 6: Calculate Ì±ÖÌ†µ = Ì±¢Ì†µÌ±ÉÌ†µ	 + 	Ì±£Ì†µÌ±ÑÌ†µ. 
                    Step 7: If Ì±ÖÌ†µ = 0, B rejects the signature. Otherwise calculate Ì±üÌ†µ‚Ä≤ = Ì±ÖÌ†µ 	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ÅÌ†µ. Ì±ÖÌ†µ  is  
                    the abscissa of Ì±ÖÌ†µ.                                                     K           K
                    Step 8: If Ì±üÌ†µX = Ì±üÌ†µ, the signature is valid. Otherwise it is invalid.  
                    1.2  Threshold Key Sharing 
                    1.2.1  Shamir‚Äôs Secret Sharing Scheme 
                    Shamir‚Äôs  Secret  Sharing  scheme  solves  the  problem  of  secure  key 
                    management. The design of modern cryptography mechanisms commits the 
                    security of cryptosystems to the safety of secret keys. Divulging the secret key 
                                                                    6 
                                                                     
                         
                                  
                                 compromises security, and thus key-management takes an important position 
                                 in security research and crypto-system design. Especially when one account is 
                                 managed by multiple parties with different interests, distributing the key to 
                                 multiple participants becomes troublesome where credibility and safety are 
                                 concerned.  To  combat  this  problem,  Shamir,  an  Israeli  cryptographer, 
                                 proposed a new (Ì±òÌ†µ,Ì±õÌ†µ) Threshold Secret Sharing scheme.  In this scheme, the 
                                 key is divided into Ì±õÌ†µ parts and distributed to Ì±õÌ†µ participators. Each participator 
                                 holds one key share and the key is reconstructed only when Ì±òÌ†µ key shares are 
                                 gathered.  
                                  
                                 1.2.2  Linear Key Sharing Scheme 
                                 Linear Key Sharing is an extension of Shamir‚Äôs Secret Sharing scheme, where 
                                 the requests for the main key space, sub-key space and randomly inputted 
                                 assembly are all linear, and the key construction function is also linear. Its 
                                 formal definition is as follows: 
                                 Suppose that Ì∞æÌ†µ is a finite field, Œ† is a key sharing system that realizes Access 
                                 Structure (AS), and Ì±ÜÌ†µ ‚äÇ Ì∞æÌ†µ is the main key space, then we say that Œ† will be a 
                                 linear key sharing system over Ì∞æÌ†µ, if the following requests are met: 
                                 ‚óè       Sub-key space is the linear space over Ì∞æÌ†µ, i.e.  that ‚àÄÌ±ñÌ†µ and 	‚àÉ constant Ì±ëÌ†µa 
                                         make sub-key space Ì±ÜÌ†µ ‚äÇ Ì∞æÌ†µbc. Record Œ† (Ì±†Ì†µ,Ì±üÌ†µ) as the No. j component of 
                                                                                   a                             ba,d
                                         the vector received by Ì±ÉÌ†µ from space Ì∞æÌ†µ c. This component is dependent on 
                                                                                      a
                                         main key Ì±†Ì†µ, and random number Ì±üÌ†µ.  
                                 ‚óè       Each grant set can gain the main key through the linear combination of 
                                         sub-keys, i.e. That in any grant set Ì∞∫Ì†µ ‚àà Ì∞¥Ì†µÌ±ÜÌ†µ, ‚àÉ is constant as {Ì±éÌ†µ :	Ì±ÉÌ†µ ‚àà Ì∞∫Ì†µ,1 ‚â§
                                                                                                                                                             a,d    a
                                         Ì±óÌ†µ ‚â§ Ì±ëÌ†µa} and makes any main key Ì±†Ì†µ, and random number Ì±üÌ†µ, with the formula 
                                                                                                             7 
                                                                                                               
                                        
                             
                                   below:                            Ì±†Ì†µ =                        Ì±éÌ†µ    ‚àô Œ†   (Ì±†Ì†µ, Ì±üÌ†µ). 
                                                                              	kc‚ààl     ,jdjbc a,d         a,d
                            1.2.3  Shamir‚Äôs Scheme and Polynomial Interpolation 
                            Shamir designed the threshold secret sharing scheme based on Lagrange's 
                            polynomial interpolation by combining properties of a polynomial over a finite 
                            field  and  Lagrange‚Äôs  reconstruction  polynomial  theory.  Concrete schemes 
                            are as follows: 
                                ‚óè      Key Sharing Process 
                              1)     When sharing key Ì±†Ì†µ, the key owner generates a random Ì±òÌ†µ‚àí1 degree 
                                     polynomial  over  finite  fieldÔºöÌ±ìÌ†µ Ì±•Ì†µ = Ì±†Ì†µ + Ì±éÌ†µ Ì±•Ì†µ + ‚ãØ+ Ì±éÌ†µ                                Ì±•Ì†µoQ, ,  obviously 
                                     Ì±ìÌ†µ 0 = Ì±†Ì†µ.                                                           ,               oQ,
                              2)     The  key  owner  selects  random  number 	Ì±•Ì†µ ,Ì±•Ì†µ ‚Ä¶,Ì±•Ì†µ  and  computes 
                                     	Ì±ìÌ†µ Ì±•Ì†µ   , Ì±ìÌ†µ Ì±•Ì†µ  ‚Ä¶,Ì±ìÌ†µ Ì±•Ì†µ      .                                          ,    )       q
                                           ,        )           q
                              3)     Each participant Ì±ÉÌ†µ gets its key share Ì±†Ì†µ = (Ì±•Ì†µ ,Ì±ìÌ†µ Ì±•Ì†µ ). 
                                                                 a                               a       a       a
                                ‚óè      Key Reconstructing Process 
                            From the key sharing process we know Ì±†Ì†µ = (Ì±•Ì†µ ,Ì±ìÌ†µ Ì±•Ì†µ ) is a point on the curve 
                                                                                              a        a      a
                            Ì±ìÌ†µ Ì±•Ì†µ . According to Lagrange's polynomial interpolation method, any Ì±òÌ†µ points 
                            of Ì±ìÌ†µ Ì±•Ì†µ  will reconstruct Ì±ìÌ†µ Ì±•Ì†µ :                  o                o     Ì±•Ì†µ ‚àí Ì±•Ì†µ
                                                                   Ì±ìÌ†µ Ì±•Ì†µ   =        Ì±ìÌ†µ Ì±•Ì†µ                      d  
                                                                                          a            Ì±•Ì†µ ‚àíÌ±•Ì†µ
                                                                               ar,           dr,,dsa d          a
                            set Ì±•Ì†µ = 0Ôºåthen	Ì±†Ì†µ is reconstructedÔºö 
                                                                              o               o         Ì±•Ì†µ
                                                                      Ì±†Ì†µ =       Ì±ìÌ†µ Ì±•Ì†µ                   d     
                                                                                       a            Ì±•Ì†µ ‚àíÌ±•Ì†µ
                                                                            ar,           dr,,dsa d          a
                                                                                            8 
                                                                                              
                                  
                           
                          simplifiedÔºö                                             o
                                                                          Ì±†Ì†µ =       Ì±èÌ†µ Ì±ìÌ†µ Ì±•Ì†µ    
                                                                                 ar, a       a
                          Where                                                      o        Ì±•Ì†µ
                                                                          Ì±èÌ†µ  =                d     
                                                                            a             Ì±•Ì†µ ‚àíÌ±•Ì†µ
                                                                                 dr,,dsa d         a
                                      
                          1.3  Secure Multi-Party Computation 
                          1.3.1  Background 
                          With the rapid development of the Internet, more and more application 
                          scenarios  need  computed  results  to  be  coordinated  between  users. 
                          Users  participating  in  coordinating  computing  want  to  share  the 
                          computed data with other users, however, due to privacy protection 
                          and data safety concerns, this sharing proves difficult. The inability to 
                          share the results leads to inefficient resource utilization and prevents 
                          realization of some these application scenarios. 
                          Secure multi-party computation solved the problem and also provides 
                          the  theoretical  basis  for  solving  the  conflict  between  data-privacy 
                          protection and coordinative computing. 
                          Secure  multi-party  computation  is  both  the  theoretical  basis  of 
                          distributed  cryptography  and  a  fundamental  problem  of  distributed 
                          computing. It solves the problem so that users can accomplish a task by 
                          coordinative computing  without  leaking  any  private  information  in  a 
                                                                                       9 
                                                                                         
                                
                          
                         mutually distrustful multi-user network. Simply speaking, secure multi-
                         party  computation  is  about  a  group  of  participants,  referred  to  as 
                         Ì±ÉÌ†µ  ‚Ä¶‚Ä¶Ì±ÉÌ†µ ,  who  work  together  to  securely  compute  the  function 
                          ,         q
                         Ì±ìÌ†µ Ì±•Ì†µ , ‚Ä¶‚Ä¶,Ì±•Ì†µ       =(Ì±¶Ì†µ ,‚Ä¶‚Ä¶,Ì±¶Ì†µ ).  The Ì±õÌ†µ inputs  of  function	Ì±ìÌ†µare  held  by Ì±õÌ†µ 
                              ,          q         ,          q
                         participants, one each. Assuming Ì±ÉÌ†µ holds the secret input Ì±•Ì†µ , after the 
                                                                                a                                      a
                         computation Ì±ÉÌ†µ gets output Ì±¶Ì†µ . In this situation,  security  requires  that 
                                               a                       a
                         even  if  some  participants  cheat  during  the  computing  process,  the 
                         correctness of the computing result is still ensured. That means every 
                         participant gets the correct output Ì±¶Ì†µ  and all participants‚Äô input remain 
                                                                                 a
                         privileged. Ì±ÉÌ†µ  gets  no  extra  information  besides (Ì±•Ì†µ ,Ì±¶Ì†µ ) through  the 
                                            a                                                                a   a
                         computation. 
                         So far, the theory of secure multi-party computation 
                         has provided rich theory and application results. It will be an 
                         indispensable part of computer security. 
                          
                        1.3.2  Classification 
                         At present the secure multi-party computation protocol can be divided into 
                         four categories based on different implementation methods: 
                             ‚óè     VSS Sub-Protocol 
                         Most existing secure multi-party computation protocols adopt the Verifiable 
                         Secret Sharing (VSS) sub-protocol as the basis of protocol construction, which 
                         is suitable for computing functions over any finite field. Any function over a 
                         finite  field  can  be  represented  by  a  directed  graph  of  field  addition  and 
                         multiplication calculations. As long as the addition and multiplication can be 
                         securely calculated, the calculation of any function over the finite field can be 
                                                                                  10 
                                                                                    
                               
                    
                   completed by computing each addition and multiplication calculation. 
                      ‚óè    Mix and Match 
                   The secure multi-party computation protocol based on VSS can calculate any 
                   function,  but  it  cannot  efficiently  calculate  Boolean  functions.  Therefore, 
                   another secure multi-party protocol is proposed - Mix and Match. The basic 
                   idea of this protocol is that the participant uses the secret sharing scheme to 
                   share the private key, and the public key of the system is open. During the 
                   protocol process, the participant randomly encrypts the public key used by 
                   himself, then opens his own encrypted result, and finally all participants get 
                   the common output through Mix and Match. 
                      ‚óè    Oblivious Transfer 
                   The secure multi-party computation protocol based on oblivious transfer (OT) 
                   is  used  to  calculate  any  bit-wise  operation  function.  It  uses  the  OT  sub-
                   protocol to perform the three basic operations, ‚Äúand‚Äù, ‚Äúor‚Äù, and ‚Äúnot‚Äù, 
                   deconstructs any bit-wise operation function into a combination of the three 
                   basic  operations,  and  finally  iteratively  calculates  any  bit-wise  operation 
                   functions. 
                      ‚óè    Homomorphic Encryption 
                   The  secure  multi-party  computation  protocol  based  on  Homomorphic 
                   Encryption can resist active attacks. The idea is to select an algorithm such that 
                   any  function  calculation  is  deconstructed  into  a  sequence  of  atomic 
                   computations. The input and output of the atomic computations are both 
                   encrypted using the homomorphic encryption algorithm, the final results get 
                   encrypted, and only specific participants can get the plaintext results. 
                    
                                                               11 
                                                                 
                        
                    
                   1.4  Ring Signatures 
                   A Ring Signature is a digital signature used by a group of users, each of which 
                   have keys to perform the signature. The Ring Signature was first invented in 
                   2001 by Ron Rivest as a special kind of group signature. Group signatures 
                   need a trusted and secure setup which means that the signer can be traced by 
                   the trust center. Ring Signature solves this serious problem by removing the 
                   trust center and secure setup,  the signer is absolutely anonymous. 
                   Since the Ring Signature was invented, many practical schemes have been 
                   designed based on Elliptic Curve Cryptography (ECC), such as the Trapdoor 
                   Technique. Generally speaking, there are four kinds of Ring Signatures: 
                      ‚óè    Threshold Ring Signature 
                      ‚óè    Linkable Ring Signature 
                      ‚óè    Ring Signature with Revocable Anonymity 
                      ‚óè    Deniable Ring Signature 
                   In order to provide the anonymity in Smart Contract Token transactions, a kind 
                   of Ring Signature based on ECC is implemented on Wanchain. 
                   2  Locked Account System  
                   2.1  Secure Multi-Party Computation Operation 
                   Addition,  multiplication,  and  unary  inverse  are  the  three  basic 
                   operations over a finite field. Any calculation can be converted into a 
                   sequence of operations of addition, multiplication, and unary inverse 
                   operations over this finite field. So long as the multi-party computation 
                   over  the  finite  field  can  complete  the  three  basic  operations,  any 
                                                               12 
                                                                 
                        
                         
                        calculation process can be obtained in an iterative way through basic 
                        multi-party computation. In the following sections, the basic operations 
                        of the secure multi-party computation algorithm are introduced under a 
                        secret sharing scheme based on Lagrange's polynomial interpolation. 
                         
                        2.1.1  Addition 
                        It  is  necessary to determine a polynomial under the secret sharing scheme 
                        based  on  Lagrange's  polynomial  interpolation.  The  shared  secret  is  the 
                        constant  term  of  the  polynomial,  and  a  secret  share  is  the  value  of  this 
                        polynomial at some point.  
                        Without  loss  of  generality,  assume  that ÌªºÌ†µ, ÌªΩÌ†µ are  two  shared  secrets.  The 
                        corresponding  polynomials  are Ì±ìÌ†µ Ì±•Ì†µ „ÄÅf Ì±•Ì†µ  and  the  participant Ì±ÉÌ†µ  has  the 
                                                                       v         x                                    a
                        secret  share ÌªºÌ†µ = Ì±ìÌ†µ Ì±ñÌ†µ , ÌªΩÌ†µ = Ì±ìÌ†µ Ì±ñÌ†µ .  The  participant Ì±ÉÌ†µ  wants  to  get  the  secret 
                                            a    v        a    x                               a
                        share  of ÌªºÌ†µ + ÌªΩÌ†µÔºåso  he  needs  to  construct  a  polynomial Ì±ìÌ†µ(Ì±•Ì†µ) such  that  the 
                        constant  term  is ÌªºÌ†µ + ÌªΩÌ†µÔºåand Ì±ÉÌ†µ  is  calculated  to  get Ì±ìÌ†µ(Ì±ñÌ†µ).  The  construction 
                                                                   a
                        process is as followsÔºö 
                         
                          ‚àµ		ÌªºÌ†µ „ÄÅÌªΩÌ†µ  are  the  secret  share of ÌªºÌ†µ„ÄÅÌªΩÌ†µÔºåand the corresponding polynomials 
                               a    a
                        are Ì±ìÌ†µ (Ì±•Ì†µ)„ÄÅÌ±ìÌ†µ (Ì±•Ì†µ) 
                              v        x                           oQ,                                            oQ,
                        ‚à¥ 	Ì±ìÌ†µ (Ì±•Ì†µ) = ÌªºÌ†µ + Ì±éÌ†µ   Ì±•Ì†µ + ‚ãØ+Ì±éÌ†µ         Ì±•Ì†µ    				Ì±ìÌ†µ (Ì±•Ì†µ) = ÌªΩÌ†µ + Ì±éÌ†µ  Ì±•Ì†µ + ‚ãØ+Ì±éÌ†µ         Ì±•Ì†µ     
                            v               v,,            v,oQ,           x               x,,            x,oQ,
                        Define Ì±ìÌ†µ(Ì±•Ì†µ) = Ì±ìÌ†µ (Ì±•Ì†µ) +	Ì±ìÌ†µ (Ì±•Ì†µ),  then	Ì±ìÌ†µ(Ì±ñÌ†µ) = Ì±ìÌ†µ (Ì±ñÌ†µ) +	Ì±ìÌ†µ (Ì±ñÌ†µ) = ÌªºÌ†µ + ÌªΩÌ†µ  
                                            v         x                        v         x         a     a
                        Obviously Ì±ìÌ†µ(Ì±•Ì†µ) is  a  polynomial  of Ì±òÌ†µ ‚àí 1 and  the  constant  term  is ÌªºÌ†µ + ÌªΩÌ†µ.  The 
                        value of the polynomial is Ì±ìÌ†µ(Ì±ñÌ†µ) at point	Ì±ñÌ†µ. 
                          ‚à¥ ÌªæÌ†µ = Ì±ìÌ†µ(Ì±ñÌ†µ) is the secret share of ÌªºÌ†µ + ÌªΩÌ†µ 
                              a
                        The above construction process gets a secure multi-party computation 
                                                                               13 
                                                                                 
                             
                      
                     protocol for the addition operation. 
                      
      
                        MPC Protocol For Addition Operation 
                       InputÔºöÌªºÌ†µ‚Ä≤s secret share ÌªºÌ†µ , ÌªΩÌ†µ‚Ä≤s secret share ÌªΩÌ†µ  
                                                a                    a
                        OutputÔºö	(ÌªºÌ†µ + ÌªΩÌ†µ)‚Ä≤s secret share 	ÌªæÌ†µ  
                           Ì±•Ì†µÌªæÌ†µ = ÌªºÌ†µ + ÌªΩÌ†µ                a
                       a   a   a
                      
                     2.1.2  Multiplication 
                     Defining ÌªºÌ†µ, ÌªΩÌ†µ as two shared secrets, the corresponding polynomial are Ì±ìÌ†µ (Ì±•Ì†µ), 
                                                                                                             v
                     Ì±ìÌ†µ (Ì±•Ì†µ). Participant Ì±ÉÌ†µ  has the secret shares ÌªºÌ†µ = Ì±ìÌ†µ (Ì±ñÌ†µ), ÌªΩÌ†µ = Ì±ìÌ†µ (Ì±ñÌ†µ), respectively. The 
                      x                    a                            a    v      a    x
                     participant directly computes the products of secret shares ÌªºÌ†µ , ÌªΩÌ†µ  locally.  If 
                                                                                                 a  a
                     after  computing,  the  constant  term  of  polynomial  of  shared  secret ÌªºÌ†µÌªΩÌ†µ is 
                     actually ÌªºÌ†µÌªΩÌ†µ, then the polynomial degree is 2(Ì±òÌ†µ ‚àí 1), and we need to lower the 
                     degree of the polynomial. 
                     If  (Ì±ìÌ†µ (Ì±ñÌ†µ), Ì±ìÌ†µ (Ì±ñÌ†µ))  is  the  secret  share  that  possessed  by  the  participant Ì±ÉÌ†µ ,  the 
                          v     x                                                                           a
                     product of Ì±ìÌ†µ (Ì±•Ì†µ) and Ì±ìÌ†µ (Ì±•Ì†µ) isÔºö 
                                   v           x
                                                                             )(oQ,)
                     Ì±ìÌ†µ  (Ì±•Ì†µ) = Ì±ìÌ†µ (Ì±•Ì†µ)Ì±ìÌ†µ (Ì±•Ì†µ) = ÌªºÌ†µÌªΩÌ†µ + Ì±éÌ†µ Ì±•Ì†µ + ‚ãØ+ Ì±éÌ†µ      Ì±•Ì†µ       
                      vx         v     x                ,            )(oQ,)
                                           Ì±ìÌ†µ  (Ì±ñÌ†µ) = Ì±ìÌ†µ (Ì±ñÌ†µ)Ì±ìÌ†µ (Ì±ñÌ†µ)Ôºå1 ‚â§ Ì±ñÌ†µ ‚â§ 2(Ì±òÌ†µ ‚àí 1) + 1 
                                            vx         v    x
                     Matrix representationÔºö                           ÌªºÌ†µÌªΩÌ†µ           Ì±ìÌ†µ   1
                                       1 ‚ãØ              1               ‚ãÆ             vx
                                        ‚ãÆ   ‚ã±           ‚ãÆ )(oQ,)   Ì±éÌ†µ         =         ‚ãÆ         
                                       1 ‚ãØ (2Ì±òÌ†µ‚àí1)                    )(oQ,)      Ì±ìÌ†µ   2Ì±òÌ†µ ‚àí 1
                                                                     14            vx
                                                                       
                          
                                
                                                                                                       
                               Take the upper coefficient matrix as Ì∞¥Ì†µ, obviously Ì∞¥Ì†µ is a nonsingular matrix. 
                               Then take the inverse matrix of Ì∞¥Ì†µ as Ì∞¥Ì†µQ,, which is a constant matrix. Taking 
                               (ÌºÜÌ†µ ,‚àô‚àô‚àô, ÌºÜÌ†µ       ) as the first line of matrix Ì∞¥Ì†µQ,, thenÔºö 
                                   ,       )oQ,
                               ÌªºÌ†µÌªΩÌ†µ = ÌºÜÌ†µ Ì±ìÌ†µ       (1) +‚àô‚àô‚àô +ÌºÜÌ†µ            Ì±ìÌ†µ   (2Ì±òÌ†µ ‚àí 1) 
                                           , vx                    )oQ, vx
                               Each participant randomly selects Ì±òÌ†µ ‚àí 1of the 2Ì±òÌ†µ ‚àí 1polymerization‚Ñé (Ì±•Ì†µ),‚àô‚àô‚àô
                               , ‚Ñé        (Ì±•Ì†µ)Ôºåand is required to meet ‚Ñé (0) = Ì±ìÌ†µ (Ì±ñÌ†µ).                                                                  ,
                                   )oQ,                              )oQ,                       a            vx
                               If you defineÌ∞ªÌ†µ Ì±•Ì†µ =                  ar, ÌºÜÌ†µa‚Ñéa Ì±•Ì†µ Ôºåthen obviouslyÔºö 
                                                 Ì∞ªÌ†µ 0 = )oQ,ÌºÜÌ†µ ‚Ñé 0 =ÌºÜÌ†µ Ì±ìÌ†µ                           1 +‚àô‚àô‚àô+ÌºÜÌ†µ               Ì±ìÌ†µ      2Ì±òÌ†µ ‚àí 1 = ÌªºÌ†µÌªΩÌ†µ 
                                                                ar,      a  a             , vx )oQ,                  )oQ, vx
                                                                                     Ì∞ªÌ†µ Ì±óÌ†µ     =           ÌºÜÌ†µ ‚Ñé    Ì±óÌ†µ   
                                                                                                    ar,      a  a
                                
                               So Ì∞ªÌ†µ(Ì±•Ì†µ) is  the  polymerization  of  sharing  secret  of ÌªºÌ†µÌªΩÌ†µ and Ì∞ªÌ†µ(Ì±ñÌ†µ) is  the  secret 
                               share. 
                                
        
                        MPC Protocol For Multiplication Operation 
                          InputÔºöÌªºÌ†µ‚Ä≤s secret share is ÌªºÌ†µ , ÌªΩÌ†µ‚Ä≤s secret share is ÌªΩÌ†µ  
                                                                        a                                    a
                          OutputÔºö	(ÌªºÌ†µÌªΩÌ†µ)‚Ä≤s secret share is 	ÌªæÌ†µ  
                                                                                  a
                  1)       Ì±ÉÌ†µ  selects a random Ì±òÌ†µ ‚àí 1 degree polynomial ‚Ñé (Ì±•Ì†µ), which satisfies ‚Ñé (0) = ÌªºÌ†µ ÌªΩÌ†µ . 
                            a                                                                            a                                   a            a  a
                  2)       Ì±ÉÌ†µ  computes ‚Ñé (Ì±óÌ†µ) and sends it to	Ì±ÉÌ†µ Ôºå1 ‚â§ Ì±óÌ†µ ‚â§ 2Ì±òÌ†µ ‚àí 1 
                            a                      a                                 d
                  3)       Each  participant  Ì±ÉÌ†µ  collects  secret  shares  from  other  participants  and  computes  ÌªæÌ†µ = Ì∞ªÌ†µ Ì±ñÌ†µ =
                                                            a                                                                                                                       a
                                                                                                        15 
                                                                                                          
                                      
                          
                       )oQ,ÌºÜÌ†µ ‚Ñé Ì±ñÌ†µ , then Ì±ÉÌ†µ  gets its secret share for ÌªºÌ†µÌªΩÌ†µ:	ÌªæÌ†µ .  
                       dr,    d d              a                                        a
                          
                         2.1.3  Unary Inverse  
                         Defining ÌªºÌ†µ as  the  shared  secret,  the  corresponding  polynomial  is Ì±ìÌ†µ (Ì±•Ì†µ) and 
                                                                                                                              v
                         participant Ì±ÉÌ†µ  has the secret share ÌªºÌ†µ = Ì±ìÌ†µ (Ì±ñÌ†µ). Unary inverse computation refers 
                                           a                                 a     v   ¬Ä           Q,
                         to participant Ì±ÉÌ†µ  getting the secret share Ì±ìÌ†µ                   (Ì±ñÌ†µ) of ÌªºÌ†µ    through the computing 
                                               a                                      v                   Q,
                         of  secret  share ÌªºÌ†µa.  In  the  process  of  computing  (ÌªºÌ†µ,	ÌªºÌ†µ                    )  their  secret  share 
                         cannot be leaked. The algorithm is as follows:  
                         Participant Ì±ÉÌ†µ  selects  random  number Ì±üÌ†µ  and  polynomial Ì±îÌ†µ (Ì±•Ì†µ) to  compute 
                                           a                                         a                            a
                         secret share Ì±üÌ†µ = Ì±îÌ†µ (Ì±óÌ†µ) and sends the result to participant Ì±ÉÌ†µ . After receiving all 
                                            ad      a                    X      q                             d
                         the  secret  shares, Ì±ÉÌ†µ  computes Ì±üÌ†µ =                      Ì±üÌ†µ .  Thus,  all  participants  share  the 
                                                      d                  d      ¬Çr, ¬Ç,d
                         same random number Ì±üÌ†µ = Ì±üÌ†µ +‚àô‚àô‚àô+Ì±üÌ†µ . Using the Multi-Party Computation (MPC) 
                                                                ,          q
                         protocol for the multiplication operation, the secret share for Ì±ìÌ†µ (Ì±ñÌ†µ) of ÌªºÌ†µÌ±üÌ†µ is 
                                                                                                                        v¬É
                         obtained by computing the secret shares of ÌªºÌ†µ and Ì±üÌ†µ, and sends the result to 
                         the other participants. It can also use Lagrange‚Äôs polynomial interpolation to 
                         reconstruct ÌªºÌ†µÌ±üÌ†µ.  Defining Ì±öÌ†µ = ÌªºÌ†µÌ±üÌ†µ,  obviously  lets Ì±ìÌ†µ ¬Ä(Ì±ñÌ†µ) = Ì±öÌ†µQ,Ì±üÌ†µX,  which  is  the 
                         secret share of ÌªºÌ†µQ,.                                                   v                 a
                                                                                   
            MPC Protocol For Unary Inverse Operation 
            InputÔºöÌªºÌ†µ‚Ä≤s secret share is ÌªºÌ†µa 
            OutputÔºö	(ÌªºÌ†µQ,)‚Ä≤s secret share is 	ÌªæÌ†µ  
                                                            a
            1)     Ì±ÉÌ†µ  selects random number Ì±üÌ†µ and random polynomial	Ì±îÌ†µ (Ì±•Ì†µ). It computes Ì±üÌ†µ = Ì±îÌ†µ (Ì±óÌ†µ) and sends it to 
                     a                                    a                                      a                         ad     a
                   Ì±ÉÌ†µ , 1 ‚â§ Ì±óÌ†µ ‚â§ Ì±õÌ†µ. 
                    d
                                                                                   16 
                                                                                     
                               
                                                                              X     q
           2)    Ì±ÉÌ†µ  collects all the secret shares and computes:	Ì±üÌ†µ =                  Ì±üÌ†µ  
                  d                                                          d      ¬Çr, ¬Ç,d
           3)    Using  the  MPC  protocol  for  multiplication  operations,  compute ÌªºÌ†µÌ±üÌ†µ‚Ä≤s  secret  share Ì±ìÌ†µ (Ì±ñÌ†µ) and 
                 reconstruct ÌªºÌ†µÌ±üÌ†µ.                                                                                                v¬É
           4)    Setting Ì±öÌ†µ = ÌªºÌ†µÌ±üÌ†µ and ÌªæÌ†µ = Ì±ìÌ†µ ¬Ä(Ì±ñÌ†µ) = Ì±öÌ†µQ,Ì±üÌ†µXÔºåthen ÌªæÌ†µ  is (ÌªºÌ†µQ,)‚Ä≤s secret share for	Ì±ÉÌ†µ . 
                                            a     v               a           a                                   a
                        
                       2.2  Locked Account Generation Scheme  
                       The locked account generation scheme, is an improvement on the Lagrange 
                       interpolation polynomial-based threshold key sharing scheme. The basic idea 
                       is  to  generate  a  decentralized  locked  account  with  all  verification  nodes 
                       through threshold key sharing, where each verification node is mastering a key 
                       share of the locked account private key. This ensures that the private key of 
                       the locked account is distributed to the whole network, so it can be managed 
                       in a decentralized way. The specific algorithm is as follows:  
                                                                           
                 Locked Account Generating Algorithm 
                  
           1)    Ì±ÉÌ†µ  selects random number	Ì±ëÌ†µ  and broadcasts Ì±ëÌ†µ Ì∞∫Ì†µ through the network.  Ì∞∫Ì†µ is the base point of 
                   a                                  a                       a
                 elliptic curve. 
           2)    Ì±ÉÌ†µ  selects  a  random Ì±òÌ†µ ‚àí 1 degree polynomial  Ì±ìÌ†µ(Ì±•Ì†µ) = Ì±ëÌ†µ + Ì±éÌ†µ               Ì±•Ì†µ + ‚ãØ+Ì±éÌ†µ        Ì±•Ì†µoQ,,  sends Ì±ìÌ†µ(Ì±óÌ†µ) to Ì±ÉÌ†µ  
                   a                                                            a        a     a,,           a,oQ,                 a         d
                 through a secure channel, and broadcasts 	Ì±éÌ†µa,,Ì∞∫Ì†µ‚Ä¶‚Ä¶Ì±éÌ†µa,oQ,Ì∞∫Ì†µ through the network.  
           3)    Ì±ÉÌ†µ  verifies  oQ,Ì±óÌ†µ¬Ñ Ì±éÌ†µ   Ì∞∫Ì†µ = Ì±ìÌ†µ Ì±óÌ†µ Ì∞∫Ì†µ.  If  the  equation is valid, then Ì±ÉÌ†µ  accepts it,  else Ì±ÉÌ†µ  rejects it and 
                  d             ¬Ñr¬Ö     a,¬Ñ      a                                               d                        d
                 asks Ì±ÉÌ†µ  to resend the message.  
                         a
                                                                           17 
                                                                             
                            
                                
               4)      When all the messages are sent and accepted, each participant gets its key share: 	Ì±°Ì†µ =                                                                       q    Ì±ìÌ†µ   Ì±†Ì†µ , 
                       Ì±†Ì†µ = 1,‚Ä¶‚Ä¶,Ì±õÌ†µ                                                                                                                                         ¬Ü        dr, d
               5)      The  (Ì±òÌ†µ,Ì±õÌ†µ)  threshold  locked  account  address  is: 	Ì±éÌ†µÌ±ëÌ†µÌ±ëÌ†µÌ±üÌ†µÌ±íÌ†µÌ±†Ì†µÌ±†Ì†µ = Ì∞ªÌ†µÌ±éÌ†µÌ±†Ì†µ‚Ñé(Ì±ÑÌ†µ) ,  Ì±ÑÌ†µ =                                                    b    Ì±ëÌ†µa Ì∞∫Ì†µ  and  its 
                                                 b                                                                                                                     ar¬Ö
                       Ì±ùÌ†µÌ±üÌ†µÌ±ñÌ†µÌ±£Ì†µÌ±éÌ†µÌ±°Ì†µÌ±íÌ†µÌ±òÌ†µÌ±íÌ†µÌ±¶Ì†µ =    ar¬ÖÌ±ëÌ†µa. Reconstructing this private key requires at least Ì±òÌ†µ key shares.  
                                
                               2.3  Locked Account Signature Scheme  
                               In the current blockchain project, the Locked Account Signature scheme uses 
                               the  Elliptic  Curve  Digital  Signature  Algorithm  (ECDSA)  for  the  mainstream 
                               signature  algorithm,  which  improves  system  compatibility.  In  the  locked 
                               account signature generation process, unlike in the original ECDSA signature 
                               algorithm, the account private key and the random number participate in the 
                               ECDSA signature process in the form of a multi-party computation (MPC). The 
                               verification process of the locked account signature is the same as the original 
                               ECDSA signature verification algorithm, so only the locked account signature 
                               generation process is introduced here:  
                                                                                                      
                        Locked Account Signature Verifying Algorithm 
                         
               1)      All Participants share the same random number Ì±êÌ†µ through MPC. The Ì±ÉÌ†µ‚Ä≤ random share is Ì±êÌ†µ . 
               2)      Ì±ÉÌ†µ  computes Ì±ÖÌ†µ = Ì±êÌ†µ Ì∞∫Ì†µ and broadcasts it.                                                                                   a                                 a
                         a                       a      a                                                                       o                                                         d
               3)      When all messages are broadcasted, Ì±ÉÌ†µ computes (Ì±•Ì†µ,Ì±¶Ì†µ) =                                                       Ì±èÌ†µ Ì±ÖÌ†µ ÔºåÌ±üÌ†µ = Ì±•Ì†µ	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ùÌ†µ and Ì±èÌ†µ =                     . 
                                                         Q,                                a                                    dr, d d                                        d        dQa
               4)      Ì±ÉÌ†µ  computes the (Ì±êÌ†µ                 )‚Ä≤ share ÌºîÌ†µ  using the MPC protocol for unary inverse operation. 
                         a                                                   a
                                                                                                       18 
                                                                                                         
                                      
                           
             5)     Using the MPC protocol for multiplication operation, Ì±ÉÌ†µ computes the (Ì±êÌ†µQ,Ì±ëÌ†µ)‚Ä≤ share ÌºàÌ†µ  via ÌºîÌ†µ  and 
                                                                                                       a                                            a        a
                    Ì±°Ì†µ  where, Ì±ëÌ†µ is the private key of the Locked Account and	Ì±°Ì†µ  is the Ì±ëÌ†µ‚Ä≤ key share for Ì±ÉÌ†µ . 
                     a                                                                                    a                                   a
             6)     Afterwards, Ì±ÉÌ†µ computes Ì±†Ì†µ = ÌºîÌ†µ Ì±öÌ†µ + ÌºàÌ†µ 	Ì±üÌ†µ, Ì±ÉÌ†µ  gets its signature share Ì±†Ì†µ  and broadcasts it.  
                                        a                  a      a        a      a               Q,              Q,     a
             7)     Ì±ÉÌ†µ  computes and verifies Ì±ÖÌ†µ = Ì±¢Ì†µ Ì∞∫Ì†µ + Ì±¢Ì†µ Ì±ÑÌ†µ , 	Ì±¢Ì†µ                    =Ì±öÌ†µÌ±†Ì†µ      , Ì±¢Ì†µ   =Ì±üÌ†µÌ±†Ì†µ    and Ì±ÑÌ†µ = Ì±°Ì†µ Ì∞∫Ì†µ. If  the equation is 
                      a                                     d      d,        d) d      d,        d      d,       d            d     d
                    valid, then Ì±ÉÌ†µ  accepts signature share Ì±†Ì†µ , else Ì±ÉÌ†µ  rejects Ì±†Ì†µ . 
                                      a                                      d           a            d
             8)     When Ì±ÉÌ†µ  collects  more  than Ì±òÌ†µ signature  shares,  it  reconstructs  the  complete  signature (Ì±üÌ†µ,Ì±†Ì†µ) 
                                a
                    using Lagrange interpolating polynomials.  
                           
                          2.4  Locked Account Key Share Updating 
                          The  threshold  key  sharing  scheme,  based  on  Lagrange  interpolating 
                          polynomials, adopted by this protocol belongs to the linear key sharing 
                          scheme,  so  key  sharing  satisfies  the  homogeneity:  If  the (Ì±òÌ†µ,Ì±õÌ†µ)for 
                          threshold  key  share Ì±òÌ†µÌ±íÌ†µÌ±¶Ì†µ  is (Ì±éÌ†µ ,‚ãØ,Ì±éÌ†µ )and  the (Ì±òÌ†µ,Ì±õÌ†µ) for  threshold  key 
                                                                   ,         ,         q
                          share Ì±òÌ†µÌ±íÌ†µÌ±¶Ì†µ  is (Ì±èÌ†µ ,‚ãØ,Ì±èÌ†µ ),  then (Ì±éÌ†µ + Ì±èÌ†µ ,‚ãØ,Ì±éÌ†µ + Ì±èÌ†µ ) is  the  threshold  key 
                                          )         ,        q                  ,      ,         q       q
                          share of Ì±òÌ†µÌ±íÌ†µÌ±¶Ì†µ + Ì±òÌ†µÌ±íÌ†µÌ±¶Ì†µ . If we let Ì±òÌ†µÌ±íÌ†µÌ±¶Ì†µ = 0, then we can obtain the new (Ì±òÌ†µ,Ì±õÌ†µ) 
                                              ,          )                      )
                          threshold key share of Ì±òÌ†µÌ±íÌ†µÌ±¶Ì†µ . The specific algorithm is as follows:  
                                                                     ,
                                                                                       
                    Locked Account Key Share Updating Algorithm 
                     
             1)     Each participant Ì±ÉÌ†µ  selects  a  random polynomial to share value 0 and computes 0‚Äôs share: 
                    	(Ì±ìÌ†µ (1), ‚ãØ , Ì±ìÌ†µ (Ì±õÌ†µ))     a
                       a           a                                                   19 
                                                                                         
                                
                      
           2)   Ì±ÉÌ†µ  sends	Ì±ìÌ†µ(Ì±óÌ†µ) to Ì±ÉÌ†µ  through secure channel, Ì±óÌ†µ = 1,‚Ä¶‚Ä¶,Ì±õÌ†µ 
                 a          a        d
           3)   When all messages are sent and verified, Ì±ÉÌ†µ gets (Ì±ìÌ†µ (Ì±ñÌ†µ),‚ãØ,Ì±ìÌ†µ (Ì±ñÌ†µ)). The new key share for  then	Ì±ÉÌ†µ 
                isÔºöÌ±°Ì†µq¬ã¬å = Ì±°Ì†µ +    q   Ì±ìÌ†µ (Ì±ñÌ†µ)                       a         ,        q                                           a
                     a        a    dr, d
                      
                     3  Smart Contract Token Transaction Anonymity  
                     3.1  Ring Signature  
                     The ring signature can be divided into four parts: GEN, SIG, VER, LNK. 
                     GEN: Using the public parameters, randomly select Ì±õÌ†µ‚àí1 public keys, along 
                     with the user‚Äôs public key Ì±ÉÌ†µ, constitutes the public key set Ì±ÜÌ†µ = {Ì±ÉÌ†µ|Ì±ñÌ†µ = 1,2‚Ä¶,}. 
                                                                                                      a
                     For the user‚Äôs public and private keys, the order of point P is (Ì±ÉÌ†µ,Ì±•Ì†µ), Ì±•Ì†µ ‚àà [1,Ì±ôÌ†µ ‚àí
                     1] and Ì±ôÌ†µ. This generates public key image	Ì∞ºÌ†µ.  
                     SIG: To sign message Ì±öÌ†µ, use the public key set Ì±ÜÌ†µ = {Ì±ÉÌ†µ|Ì±ñÌ†µ = 1,2‚Ä¶,Ì±õÌ†µ}, where Ì±ÉÌ†µ is 
                                                                                       a                         ¬Ü
                     the user‚Äôs true public key. Compute signature Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ.‚Ä® 
                     VER: Based on information Ì±öÌ†µ, the public key set Ì±ÜÌ†µ and the signature Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ, 
                     verify the validity of the signature and output ‚ÄúTrue‚Äù or ‚ÄúFalse‚Äù.  
                      
                     LNK:  Using  the  set Ì∞ºÌ†µ = {Ì∞ºÌ†µ },  decide  whether  the  signature Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ has  been 
                                                     a
                     used.  
                     The specific process is described as follows:  
                     GEN: The signer using the key pair (Ì±ÉÌ†µ,Ì±•Ì†µ) where Ì±ÉÌ†µ = Ì±•Ì†µÌ∞∫Ì†µ, computes Ì∞ºÌ†µ = Ì±•Ì†µÌ∞ªÌ†µ (Ì±ÉÌ†µ), 
                                                                                                               A
                     where Ì∞ªÌ†µ  is hash function. This outputs a random point on the ECC. Then the 
                               A
                                                                      20 
                                                                        
                          
                              
                             signer randomly selects Ì±õÌ†µ ‚àí1 public keys along with Ì±ÉÌ†µ to constitute a public 
                             key address set Ì±ÜÌ†µ = {Ì±ÉÌ†µ |Ì±ñÌ†µ = 1,2‚Ä¶,Ì±õÌ†µ}, where Ì±ÉÌ†µ = Ì±ÉÌ†µ.  
                                                                 a                                  ¬Ü
                             SIG: The signer selects a random number 	{Ì±ñÌ†µ = 1,2,‚Ä¶,Ì±õÌ†µ} and {ÌºîÌ†µa|Ì±ñÌ†µ = 1,2,‚Ä¶,Ì±õÌ†µ,Ì±ñÌ†µ ‚â†
                             Ì±†Ì†µ} and computes as follows:                       Ì±ûÌ†µ Ì∞∫Ì†µ,																						Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ = Ì±†Ì†µ
                                                                   Ì∞øÌ†µ  =          a                                       
                                                                     a       Ì±ûÌ†µ Ì∞∫Ì†µ + ÌºîÌ†µ Ì±ÉÌ†µ ,																Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ ‚â† Ì±†Ì†µ
                                                                               a          a  a
                                                                              Ì±ûÌ†µ Ì∞ªÌ†µ (Ì±ÉÌ†µ ),																	Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ = Ì±†Ì†µ
                                                                 Ì±ÖÌ†µ =           a   A    a                                  
                                                                    a      Ì±ûÌ†µ Ì∞ªÌ†µ (Ì±ÉÌ†µ ) + ÌºîÌ†µ Ì∞ºÌ†µ,												Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ ‚â† Ì±†Ì†µ
                                                                             a   A    a         a
                             ComputingÔºö 
                                             Ì±êÌ†µ = Ì∞ªÌ†µ (Ì±öÌ†µ, Ì∞øÌ†µ , ‚Ä¶ , Ì∞øÌ†µ , Ì±ÖÌ†µ , ‚Ä¶ , Ì±ÖÌ†µ )ÔºåÌ∞ªÌ†µ  is hash function.  
                                                        ¬Ü        ,         q     ,         q         ¬Ü
                             ComputingÔºö                                           ÌºîÌ†µ ,																				Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ ‚â† Ì±†Ì†µ
                                                                                     a
                                                                 Ì±êÌ†µ  =               q                                      
                                                                  a        Ì±êÌ†µ ‚àí            Ì±êÌ†µ 		Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ôÌ†µ	,			Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ = Ì±†Ì†µ
                                                                                 ar,,as¬Ü a
                                                                                                 
                                                                                 Ì±ûÌ†µ ,																					Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ ‚â† Ì±†Ì†µ
                                                                   Ì±üÌ†µ  =           a                                      
                                                                    a       Ì±ûÌ†µ  ‚àíÌ±êÌ†µ Ì±•Ì†µ		Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ôÌ†µ,								Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ = Ì±†Ì†µ
                                                                              ¬Ü       ¬Ü
                                     
                             Finally generating a signature:  
                                                                     Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ = (Ì∞ºÌ†µ, Ì±êÌ†µ , ‚Ä¶ , Ì±êÌ†µ , Ì±üÌ†µ , ‚Ä¶ , Ì±üÌ†µ ) 
                                                                                            ,         q ,           q
                             VER:  When  the  verifier  verifies  the  signature,  using  message Ì±öÌ†µ ,  public 
                             parameters and Ì±ÜÌ†µ = {Ì±ÉÌ†µ|Ì±ñÌ†µ = 1,2‚Ä¶,Ì±õÌ†µ}, Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ = (Ì∞ºÌ†µ,Ì±êÌ†µ ,‚Ä¶,Ì±êÌ†µ ,Ì±üÌ†µ ,‚Ä¶,Ì±üÌ†µ ), computing:  
                                                                 a                Ì∞øÌ†µ ‚Ä≤ = Ì±üÌ†µ Ì∞∫Ì†µ + Ì±êÌ†µ Ì±ÉÌ†µ ,      ,        q ,         q
                                                                                    a        a        a   a     
                                                                               Ì±ÖÌ†µ ‚Ä≤ = Ì±üÌ†µ Ì∞ªÌ†µ (Ì±ÉÌ†µ ) + Ì±êÌ†µ Ì∞ºÌ†µ
                                                                                 a        a   A    a        a
                                                                                               21 
                                                                                                  
                                   
                                                      
                                                                                                                                                  q                                          X                X         X                 X
                                                     Verify whether the equation                                                                           Ì±êÌ†µ     =Ì∞ªÌ†µ Ì±öÌ†µ,L ,‚Ä¶,Ì∞øÌ†µ ,Ì±ÖÌ†µ ,‚Ä¶,Ì±ÖÌ†µ                                                      	Ì±öÌ†µÌ±úÌ†µÌ±ëÌ†µ	Ì±ôÌ†µ holds. If the 
                                                                                                                                                  ar, a                      ¬Ü               ,                q         ,                 q
                                                     equation holds, then the signature is valid and implement LNK.‚Ä® 
                                                     Explanation: in the process of verification, if the equation holds, then Ì∞øÌ†µa‚Ä≤ = Ì∞øÌ†µa 
                                                     andÌ±ÖÌ†µ ‚Ä≤ = Ì±ÖÌ†µ . Take Ì∞øÌ†µ ‚Ä≤ as an example to explain:‚Ä® 
                                                                     a               a                        a                                     Ì±ûÌ†µ Ì∞∫Ì†µ,																						Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ = Ì±†Ì†µ
                                                                                                                            Ì∞øÌ†µ      =                   a                                                                         
                                                                                                                                a             Ì±ûÌ†µ Ì∞∫Ì†µ + ÌºîÌ†µ Ì±ÉÌ†µ ,																Ì±ñÌ†µÌ±ìÌ†µ		Ì±ñÌ†µ ‚â† Ì±†Ì†µ
                                                                                                                                                  a                   a     a
                                                                                                                                                        Ì∞øÌ†µ ‚Ä≤ = Ì±üÌ†µ Ì∞∫Ì†µ + Ì±êÌ†µ Ì±ÉÌ†µ  
                                                                                                                                                           a               a                 a     a
                                                     Ì±ñÌ†µ  ‚â†Ì±†Ì†µ, has Ì±ûÌ†µ = Ì±üÌ†µ , ÌºîÌ†µ = Ì±êÌ†µ , obviously holds, however when Ì±ñÌ†µ = Ì±†Ì†µ: Ì∞øÌ†µ = Ì±ûÌ†µ Ì∞∫Ì†µ = (Ì±üÌ†µ +
                                                                                       a            a         a             a                                                                                                                                ¬Ü             ¬Ü                   ¬Ü
                                                     Ì±êÌ†µ Ì±•Ì†µ)Ì∞∫Ì†µ = Ì±üÌ†µ Ì∞∫Ì†µ + Ì±êÌ†µ Ì±ÉÌ†µ = Ì∞øÌ†µ ‚Ä≤,  so Ì∞øÌ†µ ‚Ä≤ = Ì∞øÌ†µ ,  similarly R ‚Ä≤ = Ì±ÖÌ†µ  holds, then the process of 
                                                        ¬Ü                       ¬Ü                ¬Ü ¬Ü                 ¬Ü                    a               a                                     a               a
                                                     VER is valid.  
                                                     LNK: Set Ì∞ºÌ†µ consists  of  all Ì∞ºÌ†µ that  appears  on  the  blockchain.  If  the  current Ì∞ºÌ†µ 
                                                     appears in the set, it shows that the public key has been used so the signature 
                                                     of transaction is invalid. If Ì∞ºÌ†µ does not appear in the set, then the signature of 
                                                     transaction is valid, and Ì∞ºÌ†µ is added into the set Ì∞ºÌ†µ.  
                                                     3.2  One-Time Account System 
                                                     3.2.1  Composition 
                                                     The one-time account system is the basis of the entire privacy transaction. 
                                                     Every user in the system has a single main account and multiple sub-accounts. 
                                                     A sub-account can also be considered as the account in the smart contract. 
                                                     Usually a sub-account is generated by a transaction sender for the receiver, as 
                                                     is shown in the following chart:  
                                                                                                                                                                                
                                                     Alice  has  a  unique  main  account (Ì∞¥Ì†µ,Ì∞µÌ†µ),  and  several  sub-accounts (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ), 
                                                                                                                                                                                                                                                                                        ,       ,
                                                     (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ), (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ), etc. When Bob makes a transaction to Alice, (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ) and (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ) 
                                                            )       )               -        -                                                                                                                                                        ,       ,                           )       )
                                                                                                                                                                                 22 
                                                                                                                                                                                     
                                                                 
                                 
                                are created through the main account (Ì∞¥Ì†µ,Ì∞µÌ†µ). When Carol makes a transaction 
                                to Alice, (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ) is created. Every transaction to Alice creates a sub-account for 
                                                    -    -
                                Alice, which is one-time account. Only Alice has the ability to manage and use 
                                these sub-accounts.  
                                3.2.2  Account Generation Algorithm  
                                Ì∞∏Ì†µ(Ì∞πÌ†µ )[Ì±üÌ†µ] is the subgroup of order Ì±üÌ†µ of the elliptic curve Ì∞∏Ì†µ/Ì∞πÌ†µ . The base point of 
                                      A                                                                                                      A                     )        -
                                Ì∞∏Ì†µ(Ì∞πÌ†µ )[Ì±üÌ†µ]  is Ì∞∫Ì†µ. Choose the elliptic curve of either Bitcoin or Ethereum Ì±¶Ì†µ = Ì±•Ì†µ +
                                7.  A
                                1.       Main Account Generation 
                                The  original  account  of  Alice  on  Wanchain  is (Ì∞¥Ì†µ,Ì±éÌ†µ),  where Ì∞¥Ì†µ = [Ì±éÌ†µ]Ì∞∫Ì†µ .  To 
                                generate the main account of the one-time account system, select a random 
                                number Ì±èÌ†µ ‚àà [1,Ì±üÌ†µ ‚àí 1] where Ì∞µÌ†µ = [Ì±èÌ†µ]Ì∞∫Ì†µ.  Set (Ì±éÌ†µ,Ì±èÌ†µ)	is  the  private  key  of  Alice‚Äôs 
                                main account, and set (Ì∞¥Ì†µ,Ì∞µÌ†µ) is the public key of Alice‚Äôs main account. Finally, 
                                Alice owns the private key (Ì±éÌ†µ,Ì±èÌ†µ) and the scan key (Ì∞¥Ì†µ,Ì±èÌ†µ).  The public key (Ì∞¥Ì†µ,Ì∞µÌ†µ) 
                                is disclosed as the address of main account.  
                                2.       Sub-Account Generation‚Ä® 
                                When Bob initiates transaction to Alice, Alice‚Äôs main account (Ì∞¥Ì†µ,Ì∞µÌ†µ) is used to 
                                generate sub-accounts (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ).‚Ä® 
                                                                                ,    ,
                                Bob generates a random number Ì±†Ì†µ ‚àà [1,Ì±üÌ†µ ‚àí1] and computes 
                                Ì±ÜÌ†µ   =[Ì±†Ì†µ]Ì∞∫Ì†µ 
                                  ,
                                Ì∞¥Ì†µ   =Ì∞¥Ì†µ+[Ì∞ªÌ†µÌ±éÌ†µÌ±†Ì†µ‚Ñé_Ì±ùÌ†µ([Ì±†Ì†µ]Ì∞µÌ†µ)]Ì∞∫Ì†µ 
                                  ,
                                The function Hash_p above maps the points on the elliptic curve to [1,Ì±üÌ†µ ‚àí1]. 
                                The sub-account generated by Alice is  
                                                                                                   (Ì∞¥Ì†µ , Ì±ÜÌ†µ ) 
                                                                                                       ,    ,
                                                                                                           23 
                                                                                                             
                                       
                            
                            Sub-account (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ) is  an  one-time account. The random number Ì±†Ì†µ remains 
                                                    ,   ,
                           undisclosed  while Ì±ÜÌ†µ ,  which  includes Ì±†Ì†µ information,  is  disclosed.  Random 
                                                          ,
                           number Ì±†Ì†µ cannot be calculated through Ì±ÜÌ†µ  and is ensured by the elliptic curve 
                                                                                           ,
                           discrete logarithm problem. Ì∞¥Ì†µ  is a component of the public key of the sub-
                                                                         ,
                           account and Ì±ÜÌ†µ  is the random factor component.  
                                                ,
                           Each sub-account of Alice is randomly based on main account	(Ì∞¥Ì†µ,Ì∞µÌ†µ).  
                            
                           3.     Sub-Account Verification 
                           Alice scans all the one-time accounts in the blockchain. Using Ì±ÜÌ†µ  and scan key 
                           (Ì∞¥Ì†µ, Ì±èÌ†µ) she computes:                                                                             ,
                                                                      Ì∞¥Ì†µX = Ì∞¥Ì†µ + [Ì∞ªÌ†µÌ±éÌ†µÌ±†Ì†µ‚Ñé([Ì±èÌ†µ]Ì±ÜÌ†µ )]Ì∞∫Ì†µ 
                                X                                       ,                          ,
                           If Ì∞¥Ì†µ  =Ì∞¥Ì†µ , then (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ) is Alice‚Äôs sub-account.  
                                ,      ,              ,   ,
                           If Ì∞¥Ì†µX ‚â† Ì∞¥Ì†µ , then (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ) is not Alice‚Äôs sub-account.  
                                ,      ,              ,   ,
                           This is because Ì∞µÌ†µ = Ì±èÌ†µÌ∞∫Ì†µ, thus  
                                                                  [Ì±†Ì†µ]Ì∞µÌ†µ = [Ì±†Ì†µÌ±èÌ†µ]Ì∞∫Ì†µ = [Ì±èÌ†µ][Ì±†Ì†µ]Ì∞∫Ì†µ = [Ì±èÌ†µ]Ì±ÜÌ†µ  
                                                                                                            ,
                           Alice is the only person who has the scan key (Ì∞¥Ì†µ,Ì±èÌ†µ), so only Alice can verify 
                           whether sub-account (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ) belongs to her or not.‚Ä® 
                                                                ,   ,
                            When  Alice  spends  the  assets  of  sub-account  (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ),  she  calculates  the 
                           corresponding private key Ì±•Ì†µ for (Ì∞¥Ì†µ ,Ì±ÜÌ†µ ):                                       ,   ,
                                                                               ,   ,
                                                                         Ì±•Ì†µ = Ì±éÌ†µ + Ì∞ªÌ†µÌ±éÌ†µÌ±†Ì†µ‚Ñé([Ì±èÌ†µ]Ì±ÜÌ†µ ) 
                                                                                                   ,
                           So with the public key component Ì∞¥Ì†µ = [Ì±•Ì†µ]Ì∞∫Ì†µ of a sub-account, Alice calculates 
                                                                                  ,
                           the corresponding private key.  
                                                                                         24 
                                                                                           
                                 
            
            
            
           3.3  Stamp System  
           The above algorithms show that the sender of a transaction is untraceable 
           when privacy is protected by the ring signature. Thus, it results in the problem 
           of figuring out which account pays the transaction fee. Wanchain solves this 
           problem by implementing the Stamp System, which is based on a one-time 
           account  system.  Each  stamp  is  an  one-time  account  in  the  stamp  system, 
           referred  as  Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±†Ì†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µ .  Technically  Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±†Ì†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µ  is  the  same  as 
           Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ .  Users  purchase  stamps  beforehand  when  conducting 
           private transactions. Stamps are pasted on the transactions to complete the 
           private transaction and each stamp can only be used once.  
           The Stamp System is a smart contract with multiple face values. The stamp 
           information of the corresponding face value purchased by the user is stored in 
           each face value storage.  
                                   25 
                                     
              
                     
                    The contact provides the stamp purchase and return functions:  
                    Stamp Purchase Function 
                    The  stamp  purchasing  function  implements  the  stamp  purchasing  service 
                    using Wancoin. If the user Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ needs  to  purchase  a  stamp,  he  sends  a 
                    transaction to transfer Wancoin with the value of the pre-purchased stamp to 
                    the  stamp  system  smart  contract  and  invokes  the  contract  purchasing 
                    function. The parameter of the  purchasing function is the one-time account 
                    generated  by  the  user,  which  will  be  stored  in  the  stamp  list  with  a 
                    corresponding value to prove that the user has purchased the stamp.  
                                         Ì±áÌ†µÌ±•Ì†µ = (Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ, Ì±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ, Ì±£Ì†µÌ±éÌ†µÌ±ôÌ†µÌ±¢Ì†µÌ±íÌ†µ, Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ, Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                                           Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ = ("Ì±ùÌ†µÌ±¢Ì†µÌ±üÌ†µÌ±êÌ†µ‚ÑéÌ±éÌ†µÌ±†Ì†µÌ±íÌ†µ", Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±†Ì†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µ) 
                    Stamp Refund Function 
                    The stamp refund function allows the user to return unused stamp. If the user 
                    Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ purchased a one-time stamp and the stamp is not used, then the user 
                    invokes the smart contract stamp refund function to get the corresponding 
                    Wancoin value back into his account. The parameters of the return function 
                    are Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±†Ì†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µ,  the stamp face value and the ring signature. When the 
                    refund transaction is confirmed, the flag Ì∞ºÌ†µ is shown in the ring signature and 
                    stored to prove that the stamp has been refunded:  
                                             Ì±áÌ†µÌ±•Ì†µ = (Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ, Ì±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ, Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ, Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                                        Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ = ("Ì±üÌ†µÌ±íÌ†µÌ±ìÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±ëÌ†µ", Ì±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ±íÌ†µÌ±°Ì†µ, Ì±£Ì†µÌ±éÌ†µÌ±ôÌ†µÌ±¢Ì†µÌ±íÌ†µ, Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                                              Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ = (Ì∞ºÌ†µ, Ì±êÌ†µ , Ì±êÌ†µ , ‚Ä¶ , Ì±êÌ†µ , Ì±üÌ†µ , Ì±üÌ†µ , ‚Ä¶ , Ì±üÌ†µ ) 
                                                              ,  )     q , )      q
                    Using the ring signature in the stamp refund function requires the user to 
                    provide the corresponding Ì∞ºÌ†µ value of the stamp to ensure that the stamp is 
                    not used and a situation where the stamp is refunded after being used does 
                    not occur.  
                                                                   26 
                                                                    
                         
                               
                              After  the  Stamp  System  is  implemented,  when  the  user  makes  a  private 
                              transaction, he first purchases a stamp in the stamp system. The face value of 
                              the stamp is decided by the user and the calculation quantity of the smart 
                              contract. As the account information of the user does not occur in Ì±áÌ†µÌ±•Ì†µ of the 
                              token transaction, the set of user stamps and a randomly selected stamp with 
                              same face value serves as the transaction sender. The ring signature of the 
                              user‚Äôs stamp ensures the transaction is valid.  
                                                     Ì±ÇÌ†µÌ±áÌ†µÌ∞¥Ì†µ_Ì±áÌ†µÌ±•Ì†µ = (Ì±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ±íÌ†µÌ±°Ì†µ, Ì±áÌ†µÌ±úÌ†µÌ±òÌ†µÌ±íÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ, Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ, Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ             ) 
                                                                                                                                    ¬ú¬Ñ¬ù¬ûA¬ú¬ã¬Ñ
                              The transaction fee deducted from the account is the face value of the used 
                              stamp.  Each  stamp  can  only  be  used  once.  When  a  miner  excavates  new 
                              blocks, the mining award is made up by the former part of Ì∞∂Ì†µÌ±úÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±èÌ†µÌ±éÌ†µÌ±†Ì†µÌ±íÌ†µ and the 
                              stamp value used in private transactions of the block, increasing the Ì∞∂Ì†µÌ±úÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±èÌ†µÌ±éÌ†µÌ±†Ì†µÌ±íÌ†µ 
                              stamp value. In order to ensure the fixed amount of Wancoin of the system, 
                              we set the address of the stamp smart contract as a fixed value, such as the 
                              hash result of string Ì±äÌ†µÌ±éÌ†µÌ±õÌ†µÌ±êÌ†µ‚ÑéÌ±éÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ±¶Ì†µÌ±†Ì†µÌ±°Ì†µÌ±íÌ†µÌ±öÌ†µ, so that nobody has the private key 
                              of the contract and the received Wancoin cannot be transferred. This means 
                              that the money in the stamp system contract is locked and the amount of 
                              Wancoin is constant against the increase of value in Ì∞∂Ì†µÌ±úÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±èÌ†µÌ±éÌ†µÌ±†Ì†µÌ±íÌ†µ.  
                               
                              3.4  Native Coin Transaction Privacy Protection  
                              The Native Coin transaction privacy protection scheme is similar to the Stamp 
                              System method and is implemented by deploying a corresponding Wancoin 
                              smart contract on Wanchain.  
                               
                                                                                                     27 
                                                                                                        
                                     
            
           3.4.1  Wancoin Smart Contract  
           A  Wancoin  smart  contract  is  deployed  on  Wanchain  like  any  other  smart 
           contract. It is similar to the Stamp System where the dispersed value of the 
           token  money  corresponds  in  a  1:1  ratio  with  Wancoin.  Wancoin  smart 
           contracts provide two functions: token purchase and token return.  
           The  token  purchase  function  allows  the  user  to  transfer  Wancoin  to  the 
           contract and receive an equal value of tokens into their one-time account. The 
           one-time account provided by the user is added to the storage list of the 
           corresponding face value in the contract.  
           The  token  return  function  is  invoked  by  the  user  by  providing  the  ring 
           signature of his one-time account. When the process is successful, Wancoin 
           with the corresponding face value will be returned to the account of the user. 
           The privacy protection process of Wancoin transactions is explained in detail 
           below.  
            
           3.4.2  Transaction Scenario  
           The transaction scenario is as follows: 
           The private key of User1‚Äôs main account is set (Ì±éÌ†µ,Ì±èÌ†µ) and the corresponding 
           public key is set (Ì∞¥Ì†µ,Ì∞µÌ†µ).  
           The private key of User2‚Äôs main account is set (Ì±êÌ†µ,Ì±ëÌ†µ) and the corresponding 
           public key is set (Ì∞∂Ì†µ,Ì∞∑Ì†µ).  
           User1 transfers Wancoin of  amount Ì±£Ì†µÌ±éÌ†µÌ±ôÌ†µÌ±¢Ì†µÌ±íÌ†µ to User2.  
                                   28 
                                     
              
                    
                   3.4.3  Transaction Flow  
                   Initiate Transaction  
                   User1  builds  a  one-time  account Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ	 ‚àí 	Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2  by  using  the  main 
                   account public key (Ì∞∂Ì†µ,Ì∞∑Ì†µ) of User2. Invoke the token purchase function of the 
                   contract Ì±äÌ†µÌ±éÌ†µÌ±õÌ†µÌ±êÌ†µÌ±úÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ using the one-time account as its parameter:  
                                     Ì±áÌ†µÌ±•Ì†µ = (Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ1, Ì±äÌ†µÌ±éÌ†µÌ±õÌ†µÌ±êÌ†µÌ±úÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ, Ì±£Ì†µÌ±éÌ†µÌ±ôÌ†µÌ±¢Ì†µÌ±íÌ†µ, Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ, Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                                       Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ = ("Ì±ùÌ†µÌ±¢Ì†µÌ±üÌ†µÌ±êÌ†µ‚ÑéÌ±éÌ†µÌ±†Ì†µÌ±íÌ†µ", Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2) 
                   Confirm Transaction Initiation 
                   The Validator receives the transaction and verifies the relationship between Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ 
                   and Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ1 .  If  Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ  is  valid,  the  Wancoin  smart  contract  is  invoked  and 
                   Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ	 ‚àí 	Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2 is stored in the account list of the corresponding value in 
                   the contract. 
                   Receive Transaction 
                   User2 scans the storage list of Ì±äÌ†µÌ±éÌ†µÌ±õÌ†µÌ±êÌ†µÌ±úÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ using his scan key. He finds that 
                   Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2 belongs to himself and selects the Ì±õÌ†µ ‚àí 1 one-time account 
                   in the corresponding face value list to generate a ring signature of Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí
                   Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2.  This  ring  signature  is  used  as  the  parameter  for  the  token  return 
                   function:            Ì±áÌ†µÌ±•Ì†µ = (Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2, Ì±äÌ†µÌ±éÌ†µÌ±õÌ†µÌ±êÌ†µÌ±úÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ, Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ, Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                                          Ì±ùÌ†µÌ±éÌ†µÌ±¶Ì†µÌ±ôÌ†µÌ±úÌ†µÌ±éÌ†µÌ±ëÌ†µ = ("Ì±üÌ†µÌ±íÌ†µÌ±ìÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±ëÌ†µ", Ì±ÇÌ†µÌ±áÌ†µÌ∞¥Ì†µÌ±ÜÌ†µÌ±íÌ†µÌ±°Ì†µ, Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                   Confirm Transaction Received  
                   The Validator receives the transaction and verifies the relationship between Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ 
                   and Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2.  If Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ  is  valid,  the  Wancoin  smart  contract  is  invoked.  The 
                   contract verifies the validity of the ring signature and makes sure that value Ì∞ºÌ†µ  
                                                              29 
                                                                
                        
                      
                     in Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ does not occur. After the confirmation, Wancoin with corresponding 
                     value is transferred to Ì∞¥Ì†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2. 
                      
                                                                                                                     
                     3.4.4  Privacy Effect Analysis 
                     The  Wancoin  transaction  privacy  protection  scheme  based  on  one-time 
                     accounts and ring signatures shows the following privacy effects:  
                      1)   By  using  one-time  accounts,  no  one  knows  who  receives  the 
                           token‚Ä®during the transaction process. ‚Ä® 
                      2)   By  using  ring  signature,  no  one  knows  which  account‚Äôs  token  the 
                           receiver is ‚Ä®drawing out during the transaction receive process. At the 
                           same time, it must ensure that token will never be repeatedly withdrawn 
                           from the same one-time account.  
                     In this scheme, a relationship is set up between the transaction initiator and 
                                                                      30 
                                                                        
                          
            
           the one-time account purchasing the token. But a relationship cannot be set 
           up  between  the  transaction  receiver  and  the  one-time  account.  Thus,  the 
           initiator cannot correspond with the receiver and privacy protection is realized. 
           To make a convenient use of the ring signature, storage with several fixed 
           dispersed face values is set in the Wancoin smart contract. Private transactions 
           with arbitrary face values cannot be performed, which will be researched in a 
           follow-up study.  
           3.5  Smart Contract Token Privacy Protection Scheme 
           3.5.1  Transaction Scenario 
           The smart contract token privacy protection scheme scenario is as follows: 
           The private key of User1's main account of is set (Ì±éÌ†µ,Ì±èÌ†µ). The public key of the 
           main account is set (Ì∞¥Ì†µ,Ì∞µÌ†µ).  
           The private key of User2‚Äôs main account is set (Ì±êÌ†µ,Ì±ëÌ†µ). The public key of the 
           main account is set (Ì∞∂Ì†µ,Ì∞∑Ì†µ).  
           The account of User1 in the smart contract is Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ1.  
           User1 wants to transfer tokens worth amount Ì±£Ì†µÌ±éÌ†µÌ±ôÌ†µÌ±¢Ì†µÌ±íÌ†µ to User2.  
           3.5.2  Transaction Flow 
           Initiate Transaction 
           User1 purchases a stamp that records Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±†Ì†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µ on the transaction to 
           make it valid. The transaction comprises four fields: TransFrom, TransTo, Data 
           and RingSig. Then it is transmitted by P2P network. The construction process 
           is as follows: 
                                   31 
                                     
              
                    
          
         Transaction Initiating Process 
          
         1)   Ì±õÌ†µ ‚àí 1 stamps with the same value of Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µtÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±†Ì†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µ are randomly selected in the stamp 
              system  to  constitute Ì±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ±íÌ†µÌ±°Ì†µ together  with Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±†Ì†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µ.  TransFrom  is Ì±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ±íÌ†µÌ±°Ì†µ. 
              This is the preparation for ring signature and the anonymity of the transaction sender.  
         2)   TransTo is the address of smart contract Ì±áÌ†µÌ±úÌ†µÌ±òÌ†µÌ±íÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ. 
         3)   Data  comprises  four  fields:  SC_TransFrom,  SC_TransTo,  SC_Value  and  SC_Sig.  The 
              construction  process  is  as  follows:  first, Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2 is  constructed  for  User2. 
              SC_TransFrom  is  Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ1  of  User1.  The  transaction  target  addresses 
              SC_TransTo is Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2 of User2. SC_Value is Ì±£Ì†µÌ±éÌ†µÌ±ôÌ†µÌ±¢Ì†µÌ±íÌ†µ. User1 calculates Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ of the 
              transaction that corresponds to Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ1. 
         4)   The construction of the transaction field RingSig: TransForm is used as the public key set 
              to construct the ring signature Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µgÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ. 
         5)   The final transaction structure:  
                                     Ì±ÇÌ†µÌ±áÌ†µÌ∞¥Ì†µ_Ì±áÌ†µÌ±•Ì†µ = (Ì±ÜÌ†µÌ±°Ì†µÌ±éÌ†µÌ±öÌ†µÌ±ùÌ†µÌ±ÜÌ†µÌ±íÌ†µÌ±°Ì†µ, Ì±áÌ†µÌ±úÌ†µÌ±òÌ†µÌ±íÌ†µÌ±õÌ†µÌ±ÜÌ†µÌ∞∂Ì†µ, Ì∞∑Ì†µÌ±éÌ†µÌ±°Ì†µÌ±éÌ†µ, Ì±üÌ†µÌ±ñÌ†µÌ±õÌ†µÌ±îÌ†µÌ±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                            Ì∞∑Ì†µÌ±éÌ†µÌ±°Ì†µÌ±éÌ†µ = (Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ1, Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2, Ì±£Ì†µÌ±éÌ†µÌ±ôÌ†µÌ±¢Ì†µÌ±íÌ†µ, Ì±†Ì†µÌ±ñÌ†µÌ±îÌ†µ) 
                   Verify Transaction 
                   After the Validator obtains the transaction, carry out the following verification 
                                                                32 
                                                                  
                        
                      
                     and calculations: 
           
          Transaction Verification Process 
           
          1)    Verify whether Ringsig in the transaction is matched with TransForm. If true , the transaction is 
                valid. Otherwise it is rejected. 
          2)    The smart contract of TransTo is invoked with the parameter of Data. It will verify whether 
                SC_Sig matches with SC_TransFrom or not. If it is matched, the token of SC_Value is reduced 
                from SC_TransFrom. Meanwhile, SC_TransTo account is created with value of SC_Value. 
                      
                     Confirm Transaction 
                     User2 confirms whether the token from User1 is successfully transferred: 
          Transaction Confirmation Process 
         1)    One-time account in smart contract is scanned with scan key. 
         2)    User2 recognizes that	Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2 belongs to himself. The corresponding private key is 
               calculated with the main private key and Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ ‚àí Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2. 
         3)    User2 then confirms the receipt of the transferred token and takes the permission of Ì±ÇÌ†µÌ±õÌ†µÌ±íÌ†µÌ±°Ì†µÌ±ñÌ†µÌ±öÌ†µÌ±íÌ†µ‚àí
               Ì±éÌ†µÌ±êÌ†µÌ±êÌ†µÌ±úÌ†µÌ±¢Ì†µÌ±õÌ†µÌ±°Ì†µ2. 
                      
                                                                      33 
                                                                        
                          
                      
                      
                                                                                                                
                     3.5.3  Privacy Effect Analysis 
                     The  smart  contract  token  privacy  protection  scheme  based  on  one-time 
                     accounts and ring signatures show the following privacy effects: 
                     1)    It ensures that the transaction sender is anonymous in the whole network 
                           by using the stamp system and ring signature scheme. 
                     2)    It ensures that the smart contract token account is isolated from the main 
                           account by a one-time address. 
                     In order to hide the transaction sender we implement the stamp system and a 
                     ring signature. The relationship between the stamp and user is traceable while 
                     the ring signature makes that very stamp untraceable. So the transaction is 
                     isolated from the real sender and privacy protection for the sender is realized. 
                     For the transaction receiver, we use the one-time account system in the smart 
                     contract. A one-time account is created for the receiver in each transaction. No 
                                                                      34 
                                                                        
                          
            
           one can know the owner of a one-time account without the corresponding 
           scan key. Thus privacy protection for the receiver is realized. 
                             
                                   35 
                                     
              
            
            
            
                                   36 
                                     
              
